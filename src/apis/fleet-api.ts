/* tslint:disable */
/* eslint-disable */
/**
 * ODIN Fleet API
 * API to access Odin Fleet, empowering developers to deploy gameservers all around the world in just a few lines of code.
 *
 * The version of the OpenAPI document: 0.8.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  App,
  AppLocationSetting,
  Auth,
  Backup,
  BackupDownload,
  Binary,
  CreateAppLocationSettingRequest,
  CreateAppRequest,
  CreateBackupRequest,
  CreateBinaryRequest,
  CreateDockerRegistryRequest,
  CreateServerConfigRequest,
  DockerRegistry,
  GetAuthTokenRequest,
  Location,
  Server,
  ServerConfig,
  ServiceLogs,
  UpdateAppLocationSettingRequest,
  UpdateDockerRegistryRequest,
} from '../models/index';
import {
    AppFromJSON,
    AppToJSON,
    AppLocationSettingFromJSON,
    AppLocationSettingToJSON,
    AuthFromJSON,
    AuthToJSON,
    BackupFromJSON,
    BackupToJSON,
    BackupDownloadFromJSON,
    BackupDownloadToJSON,
    BinaryFromJSON,
    BinaryToJSON,
    CreateAppLocationSettingRequestFromJSON,
    CreateAppLocationSettingRequestToJSON,
    CreateAppRequestFromJSON,
    CreateAppRequestToJSON,
    CreateBackupRequestFromJSON,
    CreateBackupRequestToJSON,
    CreateBinaryRequestFromJSON,
    CreateBinaryRequestToJSON,
    CreateDockerRegistryRequestFromJSON,
    CreateDockerRegistryRequestToJSON,
    CreateServerConfigRequestFromJSON,
    CreateServerConfigRequestToJSON,
    DockerRegistryFromJSON,
    DockerRegistryToJSON,
    GetAuthTokenRequestFromJSON,
    GetAuthTokenRequestToJSON,
    LocationFromJSON,
    LocationToJSON,
    ServerFromJSON,
    ServerToJSON,
    ServerConfigFromJSON,
    ServerConfigToJSON,
    ServiceLogsFromJSON,
    ServiceLogsToJSON,
    UpdateAppLocationSettingRequestFromJSON,
    UpdateAppLocationSettingRequestToJSON,
    UpdateDockerRegistryRequestFromJSON,
    UpdateDockerRegistryRequestToJSON,
} from '../models/index';

export interface CreateAppOperationRequest {
    createAppRequest?: CreateAppRequest;
}

export interface CreateAppLocationSettingOperationRequest {
    app: number;
    createAppLocationSettingRequest?: CreateAppLocationSettingRequest;
}

export interface CreateBackupOperationRequest {
    service: number;
    createBackupRequest?: CreateBackupRequest;
}

export interface CreateBinaryOperationRequest {
    app: number;
    createBinaryRequest?: CreateBinaryRequest;
}

export interface CreateDockerRegistryOperationRequest {
    createDockerRegistryRequest?: CreateDockerRegistryRequest;
}

export interface CreateServerConfigOperationRequest {
    app: number;
    createServerConfigRequest?: CreateServerConfigRequest;
}

export interface DeleteAppRequest {
    app: number;
}

export interface DeleteAppLocationSettingRequest {
    appLocationSetting: number;
}

export interface DeleteAuthTokenRequest {
    sid: string;
}

export interface DeleteBinaryRequest {
    binary: number;
}

export interface DeleteDockerRegistryRequest {
    dockerRegistry: number;
}

export interface DeleteServerConfigRequest {
    serverConfig: number;
}

export interface GetAppByIdRequest {
    app: number;
}

export interface GetAppLocationSettingsRequest {
    app: number;
}

export interface GetAuthTokenOperationRequest {
    getAuthTokenRequest?: GetAuthTokenRequest;
}

export interface GetBackupsRequest {
    service: number;
}

export interface GetBinariesRequest {
    app: number;
}

export interface GetBinaryByIdRequest {
    binary: number;
}

export interface GetDockerRegistryByIdRequest {
    dockerRegistry: number;
}

export interface GetMostRecentBackupRequest {
    service: number;
}

export interface GetServerBackupDownloadUrlRequest {
    service: number;
}

export interface GetServerByIdRequest {
    app: number;
    service: number;
}

export interface GetServerConfigByIdRequest {
    serverConfig: number;
}

export interface GetServerConfigsRequest {
    app: number;
}

export interface GetServerLogsRequest {
    service: number;
    details?: boolean;
    follow?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    since?: number;
    timestamps?: boolean;
    tail?: string;
}

export interface GetServersRequest {
    app: number;
}

export interface RestartServerRequest {
    service: number;
    body?: object;
}

export interface RestoreBackupRequest {
    service: number;
    body?: object;
}

export interface UpdateAppLocationSettingOperationRequest {
    appLocationSetting: number;
    updateAppLocationSettingRequest?: UpdateAppLocationSettingRequest;
}

export interface UpdateBinaryRequest {
    binary: number;
    createBinaryRequest?: CreateBinaryRequest;
}

export interface UpdateDockerRegistryOperationRequest {
    dockerRegistry: number;
    updateDockerRegistryRequest?: UpdateDockerRegistryRequest;
}

export interface UpdateServerConfigRequest {
    serverConfig: number;
    createServerConfigRequest?: CreateServerConfigRequest;
}

/**
 * 
 */
export class FleetApi extends runtime.BaseAPI {

    /**
     * Create an app
     */
    async createAppRaw(requestParameters: CreateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<App>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/apps`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAppRequestToJSON(requestParameters['createAppRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppFromJSON(jsonValue));
    }

    /**
     * Create an app
     */
    async createApp(requestParameters: CreateAppOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<App> {
        const response = await this.createAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new location setting
     */
    async createAppLocationSettingRaw(requestParameters: CreateAppLocationSettingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AppLocationSetting>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling createAppLocationSetting().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/apps/{app}/location-settings`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAppLocationSettingRequestToJSON(requestParameters['createAppLocationSettingRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppLocationSettingFromJSON(jsonValue));
    }

    /**
     * Create a new location setting
     */
    async createAppLocationSetting(requestParameters: CreateAppLocationSettingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AppLocationSetting> {
        const response = await this.createAppLocationSettingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a backup of the service
     */
    async createBackupRaw(requestParameters: CreateBackupOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling createBackup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/services/{service}/backup`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBackupRequestToJSON(requestParameters['createBackupRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Creates a backup of the service
     */
    async createBackup(requestParameters: CreateBackupOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a binary and the related file
     */
    async createBinaryRaw(requestParameters: CreateBinaryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Binary>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling createBinary().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/apps/{app}/binaries`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBinaryRequestToJSON(requestParameters['createBinaryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BinaryFromJSON(jsonValue));
    }

    /**
     * Create a binary and the related file
     */
    async createBinary(requestParameters: CreateBinaryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Binary> {
        const response = await this.createBinaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new docker registry
     */
    async createDockerRegistryRaw(requestParameters: CreateDockerRegistryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DockerRegistry>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/docker-registries`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateDockerRegistryRequestToJSON(requestParameters['createDockerRegistryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DockerRegistryFromJSON(jsonValue));
    }

    /**
     * Create a new docker registry
     */
    async createDockerRegistry(requestParameters: CreateDockerRegistryOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DockerRegistry> {
        const response = await this.createDockerRegistryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new server config
     */
    async createServerConfigRaw(requestParameters: CreateServerConfigOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServerConfig>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling createServerConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/apps/{app}/configs`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateServerConfigRequestToJSON(requestParameters['createServerConfigRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServerConfigFromJSON(jsonValue));
    }

    /**
     * Create a new server config
     */
    async createServerConfig(requestParameters: CreateServerConfigOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServerConfig> {
        const response = await this.createServerConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method is responsible for deleting an App record from the database. It locates the App instance using the provided ID, and if found, proceeds to delete it. Upon successful deletion, an HTTP 204 No Content response is returned, indicating that the action was successful.
     * Delete a specific app
     */
    async deleteAppRaw(requestParameters: DeleteAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling deleteApp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * This method is responsible for deleting an App record from the database. It locates the App instance using the provided ID, and if found, proceeds to delete it. Upon successful deletion, an HTTP 204 No Content response is returned, indicating that the action was successful.
     * Delete a specific app
     */
    async deleteApp(requestParameters: DeleteAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a location setting
     */
    async deleteAppLocationSettingRaw(requestParameters: DeleteAppLocationSettingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['appLocationSetting'] == null) {
            throw new runtime.RequiredError(
                'appLocationSetting',
                'Required parameter "appLocationSetting" was null or undefined when calling deleteAppLocationSetting().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/app-location-settings/{appLocationSetting}`.replace(`{${"appLocationSetting"}}`, encodeURIComponent(String(requestParameters['appLocationSetting']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete a location setting
     */
    async deleteAppLocationSetting(requestParameters: DeleteAppLocationSettingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteAppLocationSettingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Handles the deletion of a user\'s authentication tokens
     */
    async deleteAuthTokenRaw(requestParameters: DeleteAuthTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sid'] == null) {
            throw new runtime.RequiredError(
                'sid',
                'Required parameter "sid" was null or undefined when calling deleteAuthToken().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sid'] != null) {
            queryParameters['sid'] = requestParameters['sid'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/auth/token`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Handles the deletion of a user\'s authentication tokens
     */
    async deleteAuthToken(requestParameters: DeleteAuthTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteAuthTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It first finds the Binary instance by its ID. If the instance is found, it is deleted. The method then returns an HTTP 204 No Content response to indicate successful deletion.
     * Delete a specified binary
     */
    async deleteBinaryRaw(requestParameters: DeleteBinaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['binary'] == null) {
            throw new runtime.RequiredError(
                'binary',
                'Required parameter "binary" was null or undefined when calling deleteBinary().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/binaries/{binary}`.replace(`{${"binary"}}`, encodeURIComponent(String(requestParameters['binary']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * It first finds the Binary instance by its ID. If the instance is found, it is deleted. The method then returns an HTTP 204 No Content response to indicate successful deletion.
     * Delete a specified binary
     */
    async deleteBinary(requestParameters: DeleteBinaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteBinaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a specific docker registry
     */
    async deleteDockerRegistryRaw(requestParameters: DeleteDockerRegistryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['dockerRegistry'] == null) {
            throw new runtime.RequiredError(
                'dockerRegistry',
                'Required parameter "dockerRegistry" was null or undefined when calling deleteDockerRegistry().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/docker-registries/{dockerRegistry}`.replace(`{${"dockerRegistry"}}`, encodeURIComponent(String(requestParameters['dockerRegistry']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete a specific docker registry
     */
    async deleteDockerRegistry(requestParameters: DeleteDockerRegistryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteDockerRegistryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method handles the deletion of a ServerConfig record from the database. It first finds the ServerConfig instance by its ID, and if found, deletes it. Returns an HTTP 204 No Content response upon successful deletion.
     * Delete a specific server config
     */
    async deleteServerConfigRaw(requestParameters: DeleteServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['serverConfig'] == null) {
            throw new runtime.RequiredError(
                'serverConfig',
                'Required parameter "serverConfig" was null or undefined when calling deleteServerConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/server-configs/{serverConfig}`.replace(`{${"serverConfig"}}`, encodeURIComponent(String(requestParameters['serverConfig']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * This method handles the deletion of a ServerConfig record from the database. It first finds the ServerConfig instance by its ID, and if found, deletes it. Returns an HTTP 204 No Content response upon successful deletion.
     * Delete a specific server config
     */
    async deleteServerConfig(requestParameters: DeleteServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteServerConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show a specific app
     */
    async getAppByIdRaw(requestParameters: GetAppByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<App>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getAppById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppFromJSON(jsonValue));
    }

    /**
     * Show a specific app
     */
    async getAppById(requestParameters: GetAppByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<App> {
        const response = await this.getAppByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show all location settings
     */
    async getAppLocationSettingsRaw(requestParameters: GetAppLocationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AppLocationSetting>>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getAppLocationSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}/location-settings`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AppLocationSettingFromJSON));
    }

    /**
     * Show all location settings
     */
    async getAppLocationSettings(requestParameters: GetAppLocationSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AppLocationSetting>> {
        const response = await this.getAppLocationSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show all apps
     */
    async getAppsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<App>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AppFromJSON));
    }

    /**
     * Show all apps
     */
    async getApps(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<App>> {
        const response = await this.getAppsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Validates the incoming request and attempts to authenticate the user based on the provided session ID. If the user is authenticated successfully, it returns an AuthResource containing the user\'s bearer token.
     * Handles user authentication
     */
    async getAuthTokenRaw(requestParameters: GetAuthTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Auth>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetAuthTokenRequestToJSON(requestParameters['getAuthTokenRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthFromJSON(jsonValue));
    }

    /**
     * Validates the incoming request and attempts to authenticate the user based on the provided session ID. If the user is authenticated successfully, it returns an AuthResource containing the user\'s bearer token.
     * Handles user authentication
     */
    async getAuthToken(requestParameters: GetAuthTokenOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Auth> {
        const response = await this.getAuthTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all backups for the specified Docker service
     */
    async getBackupsRaw(requestParameters: GetBackupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Backup>>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling getBackups().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/services/{service}/backups`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BackupFromJSON));
    }

    /**
     * List all backups for the specified Docker service
     */
    async getBackups(requestParameters: GetBackupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Backup>> {
        const response = await this.getBackupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Eager load file types and config templates to reduce the number of queries.
     * Show all binaries
     */
    async getBinariesRaw(requestParameters: GetBinariesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Binary>>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getBinaries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}/binaries`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BinaryFromJSON));
    }

    /**
     * Eager load file types and config templates to reduce the number of queries.
     * Show all binaries
     */
    async getBinaries(requestParameters: GetBinariesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Binary>> {
        const response = await this.getBinariesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show a specific binary
     */
    async getBinaryByIdRaw(requestParameters: GetBinaryByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Binary>> {
        if (requestParameters['binary'] == null) {
            throw new runtime.RequiredError(
                'binary',
                'Required parameter "binary" was null or undefined when calling getBinaryById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/binaries/{binary}`.replace(`{${"binary"}}`, encodeURIComponent(String(requestParameters['binary']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BinaryFromJSON(jsonValue));
    }

    /**
     * Show a specific binary
     */
    async getBinaryById(requestParameters: GetBinaryByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Binary> {
        const response = await this.getBinaryByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show all docker registries
     */
    async getDockerRegistriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DockerRegistry>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/docker-registries`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DockerRegistryFromJSON));
    }

    /**
     * Show all docker registries
     */
    async getDockerRegistries(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DockerRegistry>> {
        const response = await this.getDockerRegistriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Display a specific docker registry
     */
    async getDockerRegistryByIdRaw(requestParameters: GetDockerRegistryByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DockerRegistry>> {
        if (requestParameters['dockerRegistry'] == null) {
            throw new runtime.RequiredError(
                'dockerRegistry',
                'Required parameter "dockerRegistry" was null or undefined when calling getDockerRegistryById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/docker-registries/{dockerRegistry}`.replace(`{${"dockerRegistry"}}`, encodeURIComponent(String(requestParameters['dockerRegistry']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DockerRegistryFromJSON(jsonValue));
    }

    /**
     * Display a specific docker registry
     */
    async getDockerRegistryById(requestParameters: GetDockerRegistryByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DockerRegistry> {
        const response = await this.getDockerRegistryByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Synchronizes the local database with the state of Docker nodes, then filters for active, ready worker nodes to create a unique listing of their location labels. These nodes are suitable for deployment.
     * Show a unique listing of locations based on active and ready worker nodes
     */
    async getLocationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Location>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/nodes/locations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LocationFromJSON));
    }

    /**
     * Synchronizes the local database with the state of Docker nodes, then filters for active, ready worker nodes to create a unique listing of their location labels. These nodes are suitable for deployment.
     * Show a unique listing of locations based on active and ready worker nodes
     */
    async getLocations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Location>> {
        const response = await this.getLocationsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Display the most recent backup for the specified Docker service
     */
    async getMostRecentBackupRaw(requestParameters: GetMostRecentBackupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Backup>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling getMostRecentBackup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/services/{service}/backup`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BackupFromJSON(jsonValue));
    }

    /**
     * Display the most recent backup for the specified Docker service
     */
    async getMostRecentBackup(requestParameters: GetMostRecentBackupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Backup> {
        const response = await this.getMostRecentBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a presigned URL for downloading a backup from AWS S3 if the backup method is \'archive\'
     */
    async getServerBackupDownloadUrlRaw(requestParameters: GetServerBackupDownloadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BackupDownload>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling getServerBackupDownloadUrl().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/services/{service}/backup/download`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BackupDownloadFromJSON(jsonValue));
    }

    /**
     * Generates a presigned URL for downloading a backup from AWS S3 if the backup method is \'archive\'
     */
    async getServerBackupDownloadUrl(requestParameters: GetServerBackupDownloadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BackupDownload> {
        const response = await this.getServerBackupDownloadUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Display a specific DockerService associated with the given App
     */
    async getServerByIdRaw(requestParameters: GetServerByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Server>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getServerById().'
            );
        }

        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling getServerById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}/services/{service}`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))).replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServerFromJSON(jsonValue));
    }

    /**
     * Display a specific DockerService associated with the given App
     */
    async getServerById(requestParameters: GetServerByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Server> {
        const response = await this.getServerByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show a specific server config
     */
    async getServerConfigByIdRaw(requestParameters: GetServerConfigByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServerConfig>> {
        if (requestParameters['serverConfig'] == null) {
            throw new runtime.RequiredError(
                'serverConfig',
                'Required parameter "serverConfig" was null or undefined when calling getServerConfigById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/server-configs/{serverConfig}`.replace(`{${"serverConfig"}}`, encodeURIComponent(String(requestParameters['serverConfig']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServerConfigFromJSON(jsonValue));
    }

    /**
     * Show a specific server config
     */
    async getServerConfigById(requestParameters: GetServerConfigByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServerConfig> {
        const response = await this.getServerConfigByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show all server configs
     */
    async getServerConfigsRaw(requestParameters: GetServerConfigsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ServerConfig>>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getServerConfigs().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}/configs`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServerConfigFromJSON));
    }

    /**
     * Show all server configs
     */
    async getServerConfigs(requestParameters: GetServerConfigsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ServerConfig>> {
        const response = await this.getServerConfigsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get stdout and stderr logs from a service or task
     */
    async getServerLogsRaw(requestParameters: GetServerLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServiceLogs>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling getServerLogs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['details'] != null) {
            queryParameters['details'] = requestParameters['details'];
        }

        if (requestParameters['follow'] != null) {
            queryParameters['follow'] = requestParameters['follow'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['timestamps'] != null) {
            queryParameters['timestamps'] = requestParameters['timestamps'];
        }

        if (requestParameters['tail'] != null) {
            queryParameters['tail'] = requestParameters['tail'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/services/{service}/logs`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServiceLogsFromJSON(jsonValue));
    }

    /**
     * Get stdout and stderr logs from a service or task
     */
    async getServerLogs(requestParameters: GetServerLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServiceLogs> {
        const response = await this.getServerLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show all services for a given app
     */
    async getServersRaw(requestParameters: GetServersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Server>>> {
        if (requestParameters['app'] == null) {
            throw new runtime.RequiredError(
                'app',
                'Required parameter "app" was null or undefined when calling getServers().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/apps/{app}/services`.replace(`{${"app"}}`, encodeURIComponent(String(requestParameters['app']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServerFromJSON));
    }

    /**
     * Show all services for a given app
     */
    async getServers(requestParameters: GetServersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Server>> {
        const response = await this.getServersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restarts a specific Docker service
     */
    async restartServerRaw(requestParameters: RestartServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling restartServer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/services/{service}/restart`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Restarts a specific Docker service
     */
    async restartServer(requestParameters: RestartServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.restartServerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore a backup for a specified Docker service
     */
    async restoreBackupRaw(requestParameters: RestoreBackupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['service'] == null) {
            throw new runtime.RequiredError(
                'service',
                'Required parameter "service" was null or undefined when calling restoreBackup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/services/{service}/restore`.replace(`{${"service"}}`, encodeURIComponent(String(requestParameters['service']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Restore a backup for a specified Docker service
     */
    async restoreBackup(requestParameters: RestoreBackupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.restoreBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a location setting
     */
    async updateAppLocationSettingRaw(requestParameters: UpdateAppLocationSettingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AppLocationSetting>> {
        if (requestParameters['appLocationSetting'] == null) {
            throw new runtime.RequiredError(
                'appLocationSetting',
                'Required parameter "appLocationSetting" was null or undefined when calling updateAppLocationSetting().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/app-location-settings/{appLocationSetting}`.replace(`{${"appLocationSetting"}}`, encodeURIComponent(String(requestParameters['appLocationSetting']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAppLocationSettingRequestToJSON(requestParameters['updateAppLocationSettingRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppLocationSettingFromJSON(jsonValue));
    }

    /**
     * Update a location setting
     */
    async updateAppLocationSetting(requestParameters: UpdateAppLocationSettingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AppLocationSetting> {
        const response = await this.updateAppLocationSettingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a binary and the related file
     */
    async updateBinaryRaw(requestParameters: UpdateBinaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Binary>> {
        if (requestParameters['binary'] == null) {
            throw new runtime.RequiredError(
                'binary',
                'Required parameter "binary" was null or undefined when calling updateBinary().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/binaries/{binary}`.replace(`{${"binary"}}`, encodeURIComponent(String(requestParameters['binary']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBinaryRequestToJSON(requestParameters['createBinaryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BinaryFromJSON(jsonValue));
    }

    /**
     * Update a binary and the related file
     */
    async updateBinary(requestParameters: UpdateBinaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Binary> {
        const response = await this.updateBinaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a specific docker registry
     */
    async updateDockerRegistryRaw(requestParameters: UpdateDockerRegistryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DockerRegistry>> {
        if (requestParameters['dockerRegistry'] == null) {
            throw new runtime.RequiredError(
                'dockerRegistry',
                'Required parameter "dockerRegistry" was null or undefined when calling updateDockerRegistry().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/docker-registries/{dockerRegistry}`.replace(`{${"dockerRegistry"}}`, encodeURIComponent(String(requestParameters['dockerRegistry']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDockerRegistryRequestToJSON(requestParameters['updateDockerRegistryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DockerRegistryFromJSON(jsonValue));
    }

    /**
     * Update a specific docker registry
     */
    async updateDockerRegistry(requestParameters: UpdateDockerRegistryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DockerRegistry> {
        const response = await this.updateDockerRegistryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a server config
     */
    async updateServerConfigRaw(requestParameters: UpdateServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServerConfig>> {
        if (requestParameters['serverConfig'] == null) {
            throw new runtime.RequiredError(
                'serverConfig',
                'Required parameter "serverConfig" was null or undefined when calling updateServerConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/server-configs/{serverConfig}`.replace(`{${"serverConfig"}}`, encodeURIComponent(String(requestParameters['serverConfig']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateServerConfigRequestToJSON(requestParameters['createServerConfigRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServerConfigFromJSON(jsonValue));
    }

    /**
     * Update a server config
     */
    async updateServerConfig(requestParameters: UpdateServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServerConfig> {
        const response = await this.updateServerConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
